# skeleton for the FPGA device with multiple pseudoclocks each connected to a single output

from labscript_devices import labscript_device  #, BLACS_tab, BLACS_worker, runviewer_parser

from labscript import PseudoclockDevice, Pseudoclock, ClockLine, IntermediateDevice,\
    AnalogOut, DigitalOut, LabscriptError, config

import numpy as np
import h5py

from labscript_devices import fpga_api

# Example
#
# import __init__ # only have to do this because we're inside the labscript directory
# from labscript import *
# from labscript_devices.FPGADevice import FPGADevice
#
# FPGADevice(name='fpga', usb_port='COM1')
# AnalogOut('analog0', fpga.outputs, 'ao0')
# DigitalOut('digi0', fpga.outputs, 'digi1')
#
# start()
# analog0.ramp(0, duration=3, initial=0, final=1, samplerate=1e4)
# stop(1)

def reduce_clock_instructions(clock): # FIXME: clock_resolution?
    """ Combine consecutive instructions with the same period. """

    reduced_instructions = []
    for instruction in clock:
        if instruction == 'WAIT':
            # The following period and reps indicates a wait instruction
            reduced_instructions.append({'step': 0, 'reps': 1})
            continue
        reps = instruction['reps']
        step = instruction['step']
        # see if previous instruction has same 'step' (period) as current
        if reduced_instructions and (reduced_instructions[-1]['step'] == step):
            reduced_instructions[-1]['reps'] += reps
        else:
            reduced_instructions.append({'step': step, 'reps': reps})
    # add stop instruction
    return reduced_instructions


def convert_to_clocks_and_toggles(clock, output, clock_limit):
    """ Given a list of step/reps dictionaries
    (as returned in .clock by Pseudoclock.generate_code),
    return list of (clocks, toggles) tuples (see below)

    The shortest pulse that can be generated by the step(period)/reps clock
    representation is half the clocking frequency, as triggering only occurs
    on a rising edge. Thus a given pulse sequence is not necessarily a valid
    clocking signal. By instead specifying a number of clock cycles (n_clocks)
    and the number of times which the signal should be switched over this number
    of cycles (toggles), an arbitrary digital pulse sequence is directly
    represented by this clocking signal itself, removing the need to send and
    store a separate digital data line.
    """

    ct_clock = []
    for i, tick in enumerate(clock):

        # the first (toggles)/(clocks) has a special meaning,
        # which specifies (the inital state)/(# clocks to hold it for)
        # NB. n_clocks=n => wait n-1 clock cycles before toggling
        if i == 0:
            if isinstance(output, DigitalOut):
                initial_state = output.raw_output[0]
            elif isinstance(output, AnalogOut):
                # for analog outputs, board expects zero as initial clock state
                initial_state = 0
            else:
                raise LabscriptError("Conversion to clocks and toggles not supported for output type '{}'.".format(output.__class__.__name__))

            n_clocks = int(tick['step'] * clock_limit) - 1
            ct_clock.append((n_clocks, initial_state))
            tick['reps'] -= 1  # have essentially dealt with 1 rep above
        
            # if no more reps then we are done with this instruction
            if tick['reps'] == 0:
                continue

        #period = int(round(tick['step'] / clock_resolution) * clock_resolution)
        toggles = tick['reps']
        n_clocks = int(tick['step'] * clock_limit) - 1
        ct_clock.append((n_clocks, toggles))

    return ct_clock


@labscript_device
class FPGADevice(PseudoclockDevice):
    """ A device with indiviually pseudoclocked outputs. """

    clock_limit = 100e6  # 100 MHz
    clock_resolution = 1e-9  # true value?

    description = "FPGA-Device"
    allowed_children = [Pseudoclock]

    def __init__(self, name, usb_port, n_analog=5, n_digital=5):
        # device is triggered by PC, so trigger device is None and this device becomes the master_pseudoclock
        PseudoclockDevice.__init__(self, name)

        self.BLACS_connection = usb_port

        # number of outputs of each type that device should have
        self.n_analog = n_analog
        self.n_digital = n_digital

        self.pseudoclocks = []
        self.clocklines = []
        self.output_devices = []

    # restrict devices here?
    #def add_device(...):

    @property
    def outputs(self):
        """ Return an output device to which an output can be connected. """
        n = len(self.pseudoclocks)  # the number identifying this new output (zero indexed)

        if n == (self.n_digital + self.n_analog):
            raise LabscriptError("Cannot connect more than {} outputs to the device '{}'".format(n, self.name))
        else:
            pc = Pseudoclock("fpga_pseudoclock{}".format(n), self, "clock_{}".format(n))
            self.pseudoclocks.append(pc)

            # Create the internal direct output clock_line
            cl = ClockLine("fpga_output{}_clock_line".format(n), pc, "fpga_internal{}".format(n))
            # do we really need to store the list of clocklines?
            self.clocklines.append(cl)

            # Create the internal intermediate device (outputs) connected to the above clock line
            oid = OutputIntermediateDevice("fpga_output_device{}".format(n), cl)
            self.output_devices.append(oid)
            return oid

    def generate_code(self, hdf5_file):
        # check that correct number of outputs are attached
        outputs = [output_device.output.__class__ for output_device in self.output_devices]

        n_analog = outputs.count(AnalogOut)
        n_digital = outputs.count(DigitalOut)

        if (self.n_analog != n_analog) or (self.n_digital != n_digital):
            raise LabscriptError("FPGADevice '{}' does not have enough outputs attached. "
                                 "Expected {} digital, {} analog but found {} digital, {} analog".format(self.name,
                                                                                                         self.n_digital, self.n_analog,
                                                                                                         n_digital, n_analog))

        PseudoclockDevice.generate_code(self, hdf5_file)

        # group in which to save instructions for this device
        device_group = hdf5_file.create_group("/devices/{}".format(self.name))

        for i, pseudoclock in enumerate(self.pseudoclocks):

            output = self.output_devices[i].output

            if output is None:
                raise LabscriptError("OutputDevice '{}' has no Output connected!".format(self.output_devices[i].name))

            # restrict connection names (for BLACS)
            try:
                prefix, channel = output.connection.split(' ')
                if prefix != "analog" and prefix != "digital":
                    raise ValueError
                channel = int(channel)
            except ValueError:
                raise LabscriptError("{} {} has invalid connection string '{}'. Format must be 'analog|digital #'.".format(output.description,
                                                                                                                           output.name, str(output.connection)))
            # combine instructions with equal periods
            pseudoclock.clock = reduce_clock_instructions(pseudoclock.clock)  # , self.clock_resolution)

            # change from period/reps system to clocks/toggles (see function for explanation)
            ct_clock = convert_to_clocks_and_toggles(pseudoclock.clock, output, self.clock_limit)  # , self.clock_resolution)

            clock = np.array(ct_clock, dtype=[('n_clocks', int), ('toggles', int)])

            device_group.create_dataset("clocks/{}".format(output.name),
                                        data=clock,
                                        compression=config.compression)

            # we only need to save analog data, digital outputs are
            # constructed from the clocks/toggles clocking signal
            if isinstance(output, AnalogOut):
                device_group.create_dataset("analog_data/{}".format(output.name),
                                            data=output.raw_output,
                                            compression=config.compression)

            # do we need this?
            device_group.attrs['stop_time'] = self.stop_time


class OutputIntermediateDevice(IntermediateDevice):
    """ An intermediate device that connects to some output device. """

    # description = 

    # what sort of outputs are required ?
    allowed_children = [AnalogOut, DigitalOut]

    def __init__(self, name, clock_line):
        IntermediateDevice.__init__(self, name, clock_line)
        self.output = None

    def add_device(self, device):
        """ Disallow adding multiple devices, only allowed child is a single output. """

        if self.child_devices:
            raise LabscriptError("Output '{}' is already connected to the OutputIntermediateDevice '{}'. Only one output is allowed.".format(
                self.child_devices[0].name, self.name))
        else:
            IntermediateDevice.add_device(self, device)
            self.output = device  # store reference to the output



#########
# BLACS #
#########

from labscript_devices import BLACS_tab, BLACS_worker
from blacs.tab_base_classes import Worker, define_state, \
    MODE_MANUAL, MODE_TRANSITION_TO_BUFFERED, MODE_BUFFERED, MODE_TRANSITION_TO_MANUAL
from blacs.device_base_class import DeviceTab


@BLACS_tab
class FPGADeviceTab(DeviceTab):

    def initialise_GUI(self):
        
        # placeholder values - how to make them dynamic?
        self.num_DO = 5
        self.num_AO = 5

        self.base_units = 'Hz'
        # self.base_min
        # self.base_max
        # self.base_step
        # self.base_decimals

        digital_properties = {}
        for i in range(self.num_DO):
            digital_properties["digital %s" % i] = {}
        
        # properties['base_unit'], properties['min'], properties['max'], properties['step'], properties['decimals']
        analog_properties = {}
        for i in range(self.num_AO):
            analog_properties["analog %s" % i] = {'base_unit': self.base_units,
                                                  'min': 0, 'max': 10, 'step': 1, 'decimals': 1}

        self.create_analog_outputs(analog_properties)
        self.create_digital_outputs(digital_properties)
        DDS_widgets, AO_widgets, DO_widgets = self.auto_create_widgets()
        self.auto_place_widgets(AO_widgets, DO_widgets)

        self.supports_smart_programming(True)

    def initialise_workers(self):
        self.usb_port = self.settings['connection_table'].find_by_name(self.device_name).BLACS_connection
        self.create_worker("main_worker", FPGADeviceWorker, {'usb_port': self.usb_port})
        self.primary_worker = "main_worker"

    @define_state(MODE_MANUAL | MODE_BUFFERED | MODE_TRANSITION_TO_BUFFERED | MODE_TRANSITION_TO_MANUAL, True)
    def status_monitor(self, notify_queue=None):
        """ Get status of FPGA and update the widgets in BLACS accordingly. """
        # When called with a queue, this function writes to the queue
        # when the pulseblaster is waiting. This indicates the end of
        # an experimental run.
        self.status, waits_pending = yield(self.queue_work(self.primary_worker, 'check_status'))
        
        if notify_queue is not None and self.status['waiting'] and not waits_pending:
            # Experiment is over. Tell the queue manager about it, then
            # set the status checking timeout back to every 2 seconds
            # with no queue.
            notify_queue.put('done')
            self.statemachine_timeout_remove(self.status_monitor)
            self.statemachine_timeout_add(2000, self.status_monitor)
        
        # TODO: Update widgets
        # a = ['stopped','reset','running','waiting']
        # for name in a:
            # if self.status[name] == True:
                # self.status_widgets[name+'_no'].hide()
                # self.status_widgets[name+'_yes'].show()
            # else:                
                # self.status_widgets[name+'_no'].show()
                # self.status_widgets[name+'_yes'].hide()
        
 
    @define_state(MODE_MANUAL | MODE_BUFFERED | MODE_TRANSITION_TO_BUFFERED | MODE_TRANSITION_TO_MANUAL, True)
    def start(self, widget=None):
        yield(self.queue_work(self.primary_worker, 'fpga_start'))
        self.status_monitor()

    @define_state(MODE_MANUAL | MODE_BUFFERED | MODE_TRANSITION_TO_BUFFERED | MODE_TRANSITION_TO_MANUAL, True)
    def stop(self, widget=None):
        yield(self.queue_work(self.primary_worker, 'fpga_stop'))
        self.status_monitor()

    @define_state(MODE_MANUAL | MODE_BUFFERED | MODE_TRANSITION_TO_BUFFERED | MODE_TRANSITION_TO_MANUAL, True)
    def reset(self, widget=None):
        yield(self.queue_work(self.primary_worker, 'fpga_reset'))
        self.status_monitor()

    @define_state(MODE_BUFFERED, True)
    def start_run(self, notify_queue):
        """ function called by Queue Manager to begin a buffered shot. """
        # stop monitoring the device status
        self.statemachine_timeout_remove(self.status_monitor)
        # start the shot
        self.start()
        # poll status every 100ms to notify Queue Manager at end of shot
        self.statemachine_timeout_add(100, self.status_monitor, notify_queue)


@BLACS_worker
class FPGADeviceWorker(Worker):

    def init(self):
        self.interface = fpga_api.FPGAInterface()
        self.fpga_start = self.interface.start
        self.fpga_stop = self.interface.stop
        self.fpga_send_pseudoclock = self.interface.send_pseudoclock

        # cache for smart programming
        self.smart_cache = {'clocks': {}, 'data': {}}

    def program_manual(self, values):
        """ Program device to output values when not executing a buffered shot, eg. in realtime mode. """
        # values = {current_front_panel_values}
        pass
        # return modified_front_panel_values

    def transition_to_buffered(self, device_name, h5file, initial_values, fresh_program):
        with h5py.File(h5file, 'r') as hdf5_file:
            device_group = hdf5_file["devices"][device_name]

            clocks = device_group['clocks']
            analog_data = device_group['analog_data']

        # value of each output at end of shot
        final_state = {}

        # send the pseudoclocks
        for i, output in enumerate(clocks):
            clock = clocks[output].value
            # only send if it has changed or fresh program is requested
            if fresh_program or (clock != self.smart_cache['clocks'].get(output)):
                self.smart_cache['clocks'][output] = clock
                # FIXME: remove hardcoded board_number
                self.fpga_send_pseudoclock(board_number=0, channel_number=i, clock=clock)

            # if there is no entry for this output in the analog data group, it must be a digital out
            if not analog_data.get(output):
                # then determine what the final state of the digital out is (initial state + n_toggles mod 2)
                # FIXME: check this is right - might be off by 1!
                n_toggles = sum(clock['toggles'])
                final_state[output] = clock[0]['toggles'] + (n_toggles % 2)

        # send the analog data
        for i, output in enumerate(analog_data):
            data = analog_data[output].value
            # only send if it has changed or fresh program is requested
            if fresh_program or (data != self.smart_cache['data'].get(output)):
                final_state[output] = data[-1]
                self.smart_cache['data'][output] = data
                # FIXME: remove hardcoded board_number
                self.fpga_send_pseudoclock(board_number=0, channel_number=i, data=data)

        return final_state

    def transition_to_manual(self):
        # FIXME: implement
        return True

    def check_status(self):
        # FIXME: implement
        return {'waiting': False}, False
        """
        if self.waits_pending:
            try:
                self.all_waits_finished.wait(self.h5file, timeout=0)
                self.waits_pending = False
            except zprocess.TimeoutError:
                pass
        return pb_read_status(), self.waits_pending
        """
