# skeleton for the FPGA device with multiple pseudoclocks each connected to a single output

from labscript_devices import labscript_device  #, BLACS_tab, BLACS_worker, runviewer_parser

from labscript import PseudoclockDevice, Pseudoclock, ClockLine, IntermediateDevice,\
    AnalogOut, DigitalOut, LabscriptError, config

import numpy as np

# Example
#
# import __init__ # only have to do this because we're inside the labscript directory
# from labscript import *
# from labscript_devices.FPGADevice import FPGADevice
#
# FPGADevice(name='fpga', usb_port='COM1')
# AnalogOut('analog0', fpga.outputs, 'ao0')
# DigitalOut('digi0', fpga.outputs, 'digi1')
#
# start()
# analog0.ramp(0, duration=3, initial=0, final=1, samplerate=1e4)
# stop(1)

def reduce_clock_instructions(clock): # FIXME: clock_resolution?
    """ Combine consecutive instructions with the same period. """

    reduced_instructions = []
    for instruction in clock:
        if instruction == 'WAIT':
            # The following period and reps indicates a wait instruction
            reduced_instructions.append({'step': 0, 'reps': 1})
            continue
        reps = instruction['reps']
        step = instruction['step']
        # see if previous instruction has same 'step' (period) as current
        if reduced_instructions and (reduced_instructions[-1]['step'] == step):
            reduced_instructions[-1]['reps'] += reps
        else:
            reduced_instructions.append({'step': step, 'reps': reps})
    # add stop instruction
    return reduced_instructions


def convert_to_clocks_and_toggles(clock, output, clock_limit):
    """ Given a list of step/reps dictionaries
    (as returned in .clock by Pseudoclock.generate_code),
    return list of (clocks, toggles) tuples (see below)

    The shortest pulse that can be generated by the step(period)/reps clock
    representation is half the clocking frequency, as triggering only occurs
    on a rising edge. Thus a given pulse sequence is not necessarily a valid
    clocking signal. By instead specifying a number of clock cycles (n_clocks)
    and the number of times which the signal should be switched over this number
    of cycles (toggles), an arbitrary digital pulse sequence is directly
    represented by this clocking signal itself, removing the need to send and
    store a separate digital data line.
    """

    ct_clock = []
    for i, tick in enumerate(clock):

        # the first (toggles)/(clocks) has a special meaning,
        # which specifies (the inital state)/(# clocks to hold it for)
        # NB. n_clocks=n => wait n-1 clock cycles before toggling
        if i == 0:
            if isinstance(output, DigitalOut):
                initial_state = output.raw_output[0]
            elif isinstance(output, AnalogOut):
                # for analog outputs, board expects zero as initial clock state
                initial_state = 0
            else:
                raise LabscriptError("Conversion to clocks and toggles not supported for output type '{}'.".format(output.__class__.__name__))

            n_clocks = int(tick['step'] * clock_limit) - 1
            ct_clock.append((n_clocks, initial_state))
            tick['reps'] -= 1  # have essentially dealt with 1 rep above
        
            # if no more reps then we are done with this instruction
            if tick['reps'] == 0:
                continue

        #period = int(round(tick['step'] / clock_resolution) * clock_resolution)
        toggles = tick['reps']
        n_clocks = int(tick['step'] * clock_limit) - 1
        ct_clock.append((n_clocks, toggles))

    return ct_clock


@labscript_device
class FPGADevice(PseudoclockDevice):
    """ A device with indiviually pseudoclocked outputs. """

    clock_limit = 100e6  # 100 MHz
    clock_resolution = 1e-9  # true value?

    description = "FPGA-Device"
    allowed_children = [Pseudoclock]

    def __init__(self, name, usb_port, max_outputs=None):
        # device is triggered by PC, so trigger device is None and this device becomes the master_pseudoclock
        PseudoclockDevice.__init__(self, name)

        self.BLACS_connection = usb_port

        # FIXME: probably better to have max_analog / max_digital?
        self.max_outputs = max_outputs

        self.pseudoclocks = []
        self.clocklines = []
        self.output_devices = []

    # restrict devices here?
    #def add_device(...):

    @property
    def outputs(self):
        """ Return an output device to which an output can be connected. """
        n = len(self.pseudoclocks)  # the number identifying this new output (zero indexed)

        if n == self.max_outputs:
            raise LabscriptError("Cannot connect more than {} outputs to the device '{}'".format(n, self.name))
        else:
            pc = Pseudoclock("fpga_pseudoclock{}".format(n), self, "clock_{}".format(n))
            self.pseudoclocks.append(pc)

            # Create the internal direct output clock_line
            cl = ClockLine("fpga_output{}_clock_line".format(n), pc, "fpga_internal{}".format(n))
            # do we really need to store the list of clocklines?
            self.clocklines.append(cl)

            # Create the internal intermediate device (outputs) connected to the above clock line
            oid = OutputIntermediateDevice("fpga_output_device{}".format(n), cl)
            self.output_devices.append(oid)
            return oid

    def generate_code(self, hdf5_file):
        PseudoclockDevice.generate_code(self, hdf5_file)

        # group in which to save instructions for this device
        device_group = hdf5_file.create_group("/devices/{}".format(self.name))

        for i, pseudoclock in enumerate(self.pseudoclocks):

            output = self.output_devices[i].output

            if output is None:
                raise LabscriptError("OutputDevice '{}' has no Output connected!".format(self.output_devices[i].name))

            # restrict connection names (for BLACS)
            try:
                prefix, channel = output.connection.split(' ')
                if prefix != "channel":
                    raise ValueError
                channel = int(channel)
            except ValueError:
                raise LabscriptError("{} {} has invalid connection string '{}'. Format must be 'channel #'.".format(output.description,
                                                                                                                    output.name, str(output.connection)))
            # combine instructions with equal periods
            pseudoclock.clock = reduce_clock_instructions(pseudoclock.clock)  # , self.clock_resolution)

            # change from period/reps system to clocks/toggles (see function for explanation)
            ct_clock = convert_to_clocks_and_toggles(pseudoclock.clock, output, self.clock_limit)  # , self.clock_resolution)

            clock = np.array(ct_clock, dtype=[('n_clocks', int), ('toggles', int)])

            device_group.create_dataset("clocks/{}".format(output.name),
                                        data=clock,
                                        compression=config.compression)

            # we only need to save analog data, digital outputs are
            # constructed from the clocks/toggles clocking signal
            if isinstance(output, AnalogOut):
                device_group.create_dataset("analog_data/{}".format(output.name),
                                            data=output.raw_output,
                                            compression=config.compression)

            # do we need this?
            device_group.attrs['stop_time'] = self.stop_time


class OutputIntermediateDevice(IntermediateDevice):
    """ An intermediate device that connects to some output device. """

    # description = 

    # what sort of outputs are required ?
    allowed_children = [AnalogOut, DigitalOut]

    def __init__(self, name, clock_line):
        IntermediateDevice.__init__(self, name, clock_line)
        self.output = None

    def add_device(self, device):
        """ Disallow adding multiple devices, only allowed child is a single output. """

        if self.child_devices:
            raise LabscriptError("Output '{}' is already connected to the OutputIntermediateDevice '{}'. Only one output is allowed.".format(
                self.child_devices[0].name, self.name))
        else:
            IntermediateDevice.add_device(self, device)
            self.output = device  # store reference to the output



#########
# BLACS #
#########

from labscript_devices import BLACS_tab, BLACS_worker
from blacs.tab_base_classes import Worker, define_state, \
    MODE_MANUAL, MODE_TRANSITION_TO_BUFFERED, MODE_BUFFERED, MODE_TRANSITION_TO_MANUAL
from blacs.device_base_class import DeviceTab


@BLACS_tab
class FPGADeviceTab(DeviceTab):

    def initialise_GUI(self):
        self.num_DO = 5  # placeholder
        self.num_AO = 5  # placeholder

        # self.base_units = 'Hz'
        # self.base_min
        # self.base_max
        # self.base_step
        # self.base_decimals

        #self.digital_properties = {}
        #self.analog_properties = {}
        self.create_analog_outputs(self.analog_properties)
        self.create_digital_outputs(self.digital_properties)
        dds_widgets, ao_widgets, do_widgets = self.auto_create_widgets()

        self.supports_smart_programming(True)

        # self.usb_port = self.settings['connection_table'].find_by_name(self.device_name).usb_port
        # self.create_worker("main_worker", FPGADeviceWorker, {'usb_port': self.usb_port})
        # self.primary_worker = "main_worker"


@BLACS_worker
class FPGADeviceWorker(Worker):
    
    def init(self):
        pass
        #global fpga_api; import fpga_api  # documentation says to do it like this...
        #self.interface = fpga_api

