"""Various functions for processing the clocking signals produced by labscript."""

def reduce_clock_instructions(clock):
    """Combine consecutive instructions (of a labscript clock) with the same period."""

    reduced_instructions = []
    for instruction in clock:
        if instruction == 'WAIT':
            reduced_instructions.append(instruction)
            continue
        reps = instruction['reps']
        step = instruction['step']
        # see if previous instruction has same 'step' (period) as current
        if reduced_instructions and (reduced_instructions[-1]['step'] == step):
            reduced_instructions[-1]['reps'] += reps
        else:
            reduced_instructions.append({'step': step, 'reps': reps})
    # add stop instruction
    return reduced_instructions


def process_analog_clock(clock, clock_limit):
    """Change labscript period/reps to FPGA period/reps (for analog clocks)."""
    # throw away last instruction, junk
    clock = clock[:-1]

    processed_clock = []
    for i, tick in enumerate(clock):
        # max update rate of DACs is ~1000 * the fundamental frequency, don't allow faster updates
        # FIXME: let labscript handle this via clock_resolution
        if tick['step'] * clock_limit < 1000:
            print "Requested update rate exceeds that of the DACs ({}), discarding".format(tick['step'])
        else:
            instr = (int(round(tick['step'] * clock_limit) / 2.0) - 1, tick['reps'] - 1)
            processed_clock.append(instr)

            # combine consecutive instructions with same period
            """
            if i > 0:
                if instr[0] == processed_clock[-1][0]:
                    prev_instr = list(processed_clock.pop())
                    prev_instr[1] += instr[1]
                    processed_clock.append(tuple(prev_instr))
                else:
                    processed_clock.append(instr)
            else:
                processed_clock.append(instr)
            """
    return processed_clock


def convert_to_clocks_and_toggles(clock, output, clock_limit):
    """ Given a list of step/reps dictionaries
    (as returned in .clock by Pseudoclock.generate_code),
    return list of (clocks, toggles) tuples (see below)

    The shortest pulse that can be generated by the step(period)/reps clock
    representation is half the clocking frequency, as triggering only occurs
    on a rising edge. Thus a given pulse sequence is not necessarily a valid
    clocking signal. By instead specifying a number of clock cycles (n_clocks)
    and the number of times which the signal should be switched over this number
    of cycles (toggles), an arbitrary digital pulse sequence is directly
    represented by this clocking signal itself, removing the need to send and
    store a separate digital data line.
    """

    ct_clock = []

    # FIXME: ensure this always holds
    # throw away last instruction, always seems to be junk
    clock = clock[:-1]

    for i, tick in enumerate(clock):
        # the first (toggles)/(clocks) has a special meaning,
        # which specifies (the inital state)/(# clocks to hold it for)
        # NB. n_clocks=n => wait n-1 clock cycles before toggling
        if i == 0:
            initial_state = output.raw_output[0]

            n_clocks = int(round(tick['step'] * clock_limit)) - 1
            ct_clock.append((n_clocks, initial_state))
            tick['reps'] -= 1  # have essentially dealt with 1 rep above

            # if no more reps then we are done with this instruction
            if tick['reps'] == 0:
                continue

        # subtract 1 due to auto toggling
        toggles = tick['reps'] - 1
        n_clocks = int(round(tick['step'] * clock_limit)) - 1

        # combine consecutive instructions with same number of clocks
        if i > 1:
            if n_clocks == ct_clock[-1][0]:
                prev_instr = list(ct_clock.pop())
                combined_instr = (n_clocks, prev_instr[1] + toggles + 1)
                ct_clock.append(combined_instr)
                continue

        ct_clock.append((n_clocks, toggles))

    # remove 1 from last toggles so we don't have an auto toggle at end of shot
    # FIXME: what if we have a zero in last instruction ?
    # check that the toggles of the last clock is not 0
    if ct_clock[-1][1] != 0:
        last_instr = list(ct_clock.pop())
        last_instr[1] -= 1
        ct_clock.append(tuple(last_instr))

    return ct_clock


def expand_clock(clock, clock_limit, stop_time):
    """ given a clocks/toggles clocking signal, return
        a list of times at which the clock ticks. """
    # FIXME: add clock resolution stuff
    times = []

    for i, tick in enumerate(clock):
        n_clocks, toggles = tick

        # first instruction is special, toggles gives initial state,
        # n_clocks gives number of clocks to hold it for
        if i == 0:
            times.append(n_clocks / clock_limit)
        else:
            for i in range(toggles):
                new_time = times[-1] + (n_clocks / clock_limit)
                # ensure we don't exceed the stop time
                if new_time > stop_time:
                    break
                else:
                    times.append(new_time)
    return times
